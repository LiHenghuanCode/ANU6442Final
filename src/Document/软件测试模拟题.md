# 软件测试模拟题

本文档包含两道软件测试练习题，帮助你准备黑盒测试和参数化测试。

---

## 题目 1：计算器验证器（CalculatorValidator）

### 背景

作为软件测试工程师，你需要测试不同实现的 `CalculatorValidator` 类的正确性。这些计算器验证器用于验证数学表达式的计算结果。

#### Calculator 类

`Calculator` 抽象类有一个 `calculate` 方法，接收一个 `Expression` 对象作为参数。

`Expression` 对象包含以下属性：
* `operand1`：第一个操作数（double类型）
* `operand2`：第二个操作数（double类型）
* `operator`：运算符（Operator枚举类型）
* `precision`：精度要求（整数，范围1-10，表示小数点后保留位数）

#### Operator 枚举

| 运算符 | 符号 | 说明 |
|--------|------|------|
| ADD | + | 加法 |
| SUBTRACT | - | 减法 |
| MULTIPLY | × | 乘法 |
| DIVIDE | ÷ | 除法 |
| POWER | ^ | 幂运算 |

```java
public enum Operator {
    ADD("+"), SUBTRACT("-"), MULTIPLY("×"), DIVIDE("÷"), POWER("^");
    
    private String symbol;
    
    Operator(String symbol) {
        this.symbol = symbol;
    }
    
    public String getSymbol() {
        return symbol;
    }
}
```

#### Expression 类

```java
public class Expression {
    private double operand1;
    private double operand2;
    private Operator operator;
    private int precision;
    
    public Expression(double operand1, double operand2, 
                      Operator operator, int precision) {
        this.operand1 = operand1;
        this.operand2 = operand2;
        this.operator = operator;
        this.precision = precision;
    }
    
    // Getters
    public double getOperand1() { return operand1; }
    public double getOperand2() { return operand2; }
    public Operator getOperator() { return operator; }
    public int getPrecision() { return precision; }
}
```

#### 异常类

```java
public class InvalidPrecisionException extends Exception {
    private static final long serialVersionUID = 1L;
}

public class DivisionByZeroException extends Exception {
    private static final long serialVersionUID = 1L;
}
```

---

### 期望的计算规则

正确实现的 `Calculator` 必须遵循以下规则：

#### 1. 精度处理
- `precision` 必须在 1-10 范围内（包含），否则抛出 `InvalidPrecisionException`
- 计算结果应四舍五入到指定精度
- 例如：precision=2 时，3.14159 应返回 3.14

#### 2. 基本运算规则
- **加法**：`result = operand1 + operand2`
- **减法**：`result = operand1 - operand2`
- **乘法**：`result = operand1 * operand2`
- **除法**：`result = operand1 / operand2`
  - 当 `operand2 == 0` 时，抛出 `DivisionByZeroException`
- **幂运算**：`result = operand1 ^ operand2`

#### 3. 计算示例

**示例 1：加法**
```
Expression: 5.5 + 3.7, precision=1
期望结果: 9.2
```

**示例 2：除法**
```
Expression: 10.0 ÷ 3.0, precision=2
期望结果: 3.33
```

**示例 3：幂运算**
```
Expression: 2.0 ^ 3.0, precision=1
期望结果: 8.0
```

**示例 4：精度异常**
```
Expression: 5.0 + 3.0, precision=15
期望行为: 抛出 InvalidPrecisionException
```

**示例 5：除零异常**
```
Expression: 10.0 ÷ 0.0, precision=2
期望行为: 抛出 DivisionByZeroException
```

---

### Calculator 抽象类

```java
package SoftwareTest.Practice2;

public abstract class Calculator {
    
    public double calculate(Expression expr) 
            throws InvalidPrecisionException, DivisionByZeroException {
        
        if (expr.getPrecision() < 1 || expr.getPrecision() > 10) {
            throw new InvalidPrecisionException();
        }
        
        double result = performOperation(expr);
        return round(result, expr.getPrecision());
    }
    
    protected abstract double performOperation(Expression expr) 
            throws DivisionByZeroException;
    
    protected abstract double round(double value, int precision);
}
```

---

### 你的任务

系统中有 **10 个** `Calculator` 的实现类（Calculator0 到 Calculator9）。你需要：

1. **完成参数化测试**：在 `Q1Test.java` 中编写测试用例
2. **识别正确实现**：找出所有正确实现的 Calculator
3. **识别错误实现**：找出所有错误实现的 Calculator

#### 测试要求

- 每个测试方法必须包含注解：`@Test(timeout = 1000)`
- **强烈建议**使用**黑盒测试**方法
- 使用参数化测试框架，测试将自动运行在所有10个实现上

#### 评分标准

- **满分**：所有错误的 Calculator 至少失败一个测试，所有正确的 Calculator 通过所有测试
- **扣分情况**：
  - (a) 让正确的 Calculator 失败测试
  - (b) 让错误的 Calculator 通过测试
  - 注意：(a) 的扣分比 (b) 更多
- **零分情况**：
  - 通过所有13个实现
  - 失败所有13个实现
  - 失败（所有）正确的实现

#### 不需要考虑的情况

- Expression 参数为 null
- Expression 的任何字段为 null

#### 提示

考虑以下测试场景：
- 边界值测试（precision = 1, 10, 0, 11）
- 除零情况
- 负数操作数
- 小数操作数
- 不同运算符的组合
- 精度四舍五入的准确性

---

### 参考测试用例

```java
@Test(timeout = 1000)
public void exampleTest() throws Exception {
    Expression expr = new Expression(5.5, 3.7, Operator.ADD, 1);
    double result = calculator.calculate(expr);
    assertEquals(9.2, result, 0.01);
}
```

---

### 提交文件

- `Q1Test.java`

---

## 题目 2：数据验证器（DataValidator）

### 背景

作为软件测试工程师，你需要测试不同实现的 `DataValidator` 类的正确性。这些数据验证器用于验证用户注册信息。

#### UserData 类

`validate` 方法接收一个 `UserData` 对象，该对象包含以下属性：
* `username`：用户名（String）
* `email`：电子邮件（String）
* `age`：年龄（int，范围应为18-120）
* `password`：密码（String）
* `accountType`：账户类型（AccountType枚举）

#### AccountType 枚举

| 账户类型 | 等级 | 说明 |
|---------|------|------|
| BASIC | 1 | 基础账户 |
| PREMIUM | 2 | 高级账户 |
| ENTERPRISE | 3 | 企业账户 |

```java
public enum AccountType {
    BASIC(1), PREMIUM(2), ENTERPRISE(3);
    
    private int level;
    
    AccountType(int level) {
        this.level = level;
    }
    
    public int getLevel() {
        return level;
    }
}
```

#### UserData 类

```java
public class UserData {
    private String username;
    private String email;
    private int age;
    private String password;
    private AccountType accountType;
    
    public UserData(String username, String email, int age, 
                    String password, AccountType accountType) {
        this.username = username;
        this.email = email;
        this.age = age;
        this.password = password;
        this.accountType = accountType;
    }
    
    // Getters
    public String getUsername() { return username; }
    public String getEmail() { return email; }
    public int getAge() { return age; }
    public String getPassword() { return password; }
    public AccountType getAccountType() { return accountType; }
}
```

#### 异常类

```java
public class InvalidUsernameException extends Exception {
    private static final long serialVersionUID = 1L;
}

public class InvalidEmailException extends Exception {
    private static final long serialVersionUID = 1L;
}

public class InvalidAgeException extends Exception {
    private static final long serialVersionUID = 1L;
}

public class InvalidPasswordException extends Exception {
    private static final long serialVersionUID = 1L;
}
```

---

### 期望的验证规则

正确实现的 `DataValidator` 必须遵循以下规则：

#### 1. 用户名验证（usernameScore）
- 长度必须在 3-20 个字符之间（包含）
- 只能包含字母、数字和下划线
- 必须以字母开头
- 不满足以上任一条件时抛出 `InvalidUsernameException`
- **计分规则**：
  - 基础分：10
  - 长度加分：每个字符 +2 分
  - 包含数字：+5 分
  - 包含下划线：+3 分

#### 2. 邮箱验证（emailScore）
- 必须包含恰好一个 `@` 符号
- `@` 前至少有1个字符
- `@` 后必须包含至少一个 `.`
- `.` 后至少有2个字符
- 不满足以上任一条件时抛出 `InvalidEmailException`
- **计分规则**：
  - 基础分：15
  - `@` 前的字符长度加分：每个字符 +1 分
  - 域名包含常见顶级域名（.com, .edu, .org）：+10 分

#### 3. 年龄验证（ageScore）
- 年龄必须在 18-120 范围内（包含）
- 不满足条件时抛出 `InvalidAgeException`
- **计分规则**：
  - 18-30岁：20分
  - 31-50岁：15分
  - 51-120岁：10分

#### 4. 密码验证（passwordScore）
- 长度必须至少为 8 个字符
- 必须包含至少一个大写字母
- 必须包含至少一个小写字母
- 必须包含至少一个数字
- 不满足以上任一条件时抛出 `InvalidPasswordException`
- **计分规则**：
  - 基础分：20
  - 长度加分：每个字符 +1 分
  - 包含特殊字符（!@#$%^&*）：每个 +3 分（最多+15）

#### 5. 账户类型加权（accountMultiplier）
- BASIC: 1.0倍
- PREMIUM: 1.5倍
- ENTERPRISE: 2.0倍

#### 6. 最终验证分数
```
validationScore = (usernameScore + emailScore + ageScore + passwordScore) 
                  × accountMultiplier
```

---

### 验证示例

**示例 1：有效的基础用户**
```
UserData:
  username: "alice123"
  email: "alice@example.com"
  age: 25
  password: "Pass1234"
  accountType: BASIC

计算过程：
  usernameScore = 10 + (8×2) + 5 = 31
  emailScore = 15 + 5 + 10 = 30
  ageScore = 20
  passwordScore = 20 + 8 = 28
  validationScore = (31+30+20+28) × 1.0 = 109
```

**示例 2：无效用户名**
```
UserData:
  username: "1alice"  // 以数字开头
  
期望行为: 抛出 InvalidUsernameException
```

**示例 3：无效邮箱**
```
UserData:
  email: "alice@com"  // @ 后没有 .
  
期望行为: 抛出 InvalidEmailException
```

**示例 4：无效年龄**
```
UserData:
  age: 17  // 小于18岁
  
期望行为: 抛出 InvalidAgeException
```

**示例 5：无效密码**
```
UserData:
  password: "pass"  // 长度不足8
  
期望行为: 抛出 InvalidPasswordException
```

**示例 6：企业账户高分**
```
UserData:
  username: "admin_user"
  email: "admin@company.com"
  age: 35
  password: "SecurePass123!@"
  accountType: ENTERPRISE

计算过程：
  usernameScore = 10 + (10×2) + 5 + 3 = 38
  emailScore = 15 + 5 + 10 = 30
  ageScore = 15
  passwordScore = 20 + 15 + 6 = 41
  validationScore = (38+30+15+41) × 2.0 = 248
```

---

### DataValidator 抽象类

```java
package SoftwareTest.Practice3;

public abstract class DataValidator {
    
    public int validate(UserData userData) 
            throws InvalidUsernameException, InvalidEmailException,
                   InvalidAgeException, InvalidPasswordException {
        
        int usernameScore = validateUsername(userData.getUsername());
        int emailScore = validateEmail(userData.getEmail());
        int ageScore = validateAge(userData.getAge());
        int passwordScore = validatePassword(userData.getPassword());
        
        double multiplier = getAccountMultiplier(userData.getAccountType());
        
        return (int) ((usernameScore + emailScore + ageScore + passwordScore) 
                      * multiplier);
    }
    
    protected abstract int validateUsername(String username) 
            throws InvalidUsernameException;
    
    protected abstract int validateEmail(String email) 
            throws InvalidEmailException;
    
    protected abstract int validateAge(int age) 
            throws InvalidAgeException;
    
    protected abstract int validatePassword(String password) 
            throws InvalidPasswordException;
    
    protected abstract double getAccountMultiplier(AccountType type);
}
```

---

### 你的任务

系统中有 **12 个** `DataValidator` 的实现类（DataValidator0 到 DataValidator11）。你需要：

1. **完成参数化测试**：在 `Q2Test.java` 中编写测试用例
2. **识别正确实现**：找出所有正确实现的 DataValidator
3. **识别错误实现**：找出所有错误实现的 DataValidator

#### 测试要求

- 每个测试方法必须包含注解：`@Test(timeout = 1000)`
- **强烈建议**使用**黑盒测试**方法
- 使用参数化测试框架，测试将自动运行在所有12个实现上

#### 评分标准

- **满分**：所有错误的 DataValidator 至少失败一个测试，所有正确的 DataValidator 通过所有测试
- **扣分情况**：
  - (a) 让正确的 DataValidator 失败测试
  - (b) 让错误的 DataValidator 通过测试
  - 注意：(a) 的扣分比 (b) 更多
- **零分情况**：
  - 通过所有12个实现
  - 失败所有12个实现
  - 失败（所有）正确的实现

#### 不需要考虑的情况

- UserData 参数为 null
- UserData 的任何字段为 null（除非明确测试 null 处理）

#### 提示

考虑以下测试场景：
- 边界值测试（用户名长度3和20，年龄18和120）
- 各种无效格式（用户名以数字开头，邮箱格式错误）
- 密码复杂度（仅小写、缺少数字等）
- 不同账户类型的分数计算
- 特殊字符处理
- 计分规则的准确性

---

### 参考测试用例

```java
@Test(timeout = 1000)
public void exampleTest() throws Exception {
    UserData data = new UserData(
        "alice123", 
        "alice@example.com", 
        25, 
        "Pass1234", 
        AccountType.BASIC
    );
    int score = validator.validate(data);
    assertEquals(109, score);
}

@Test(timeout = 1000, expected = InvalidUsernameException.class)
public void testInvalidUsername() throws Exception {
    UserData data = new UserData(
        "1alice",  // 以数字开头
        "alice@example.com", 
        25, 
        "Pass1234", 
        AccountType.BASIC
    );
    validator.validate(data);
}
```

---

### 提交文件

- `Q2Test.java`

---

## 黑盒测试策略提示

### 等价类划分

将输入划分为有效等价类和无效等价类：
- **有效等价类**：符合规范的输入
- **无效等价类**：违反规范的输入

### 边界值分析

测试边界附近的值：
- **上边界**：最大有效值
- **下边界**：最小有效值
- **刚好越界**：边界+1或-1

### 决策表测试

对于复杂的逻辑条件，使用决策表覆盖所有组合。

### 错误推测

基于经验推测可能出现的错误：
- 常见的编程错误（off-by-one, 符号错误）
- 特殊值处理（0, 负数, 空字符串）
- 边界条件处理

---

## 练习建议

1. **先理解规范**：仔细阅读期望行为
2. **设计测试用例**：覆盖正常情况、边界情况、异常情况
3. **编写测试代码**：使用参数化测试框架
4. **运行并分析**：观察哪些实现失败了
5. **优化测试**：增加更多边界情况测试
6. **验证正确性**：确保没有误判正确的实现

祝你测试顺利！
