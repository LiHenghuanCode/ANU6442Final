# COMP2100/6442 考试题目及参考答案

---

## Question 3: Code Quality and Refactoring
## 问题3：代码质量与重构

### 题目原文（英文）

You are planning to develop an App about Penguins as a hobby project. In order to build a prototype, you have gathered data from Kaggle, DBpedia, and by scraping posts and media from Instagram.

To get started, you planned to form the skeleton of the app and build the basic parts of your App. In particular, you want to:

1. Read in data from local files for the App. The data include various types of information/content, and are in different forms. This includes files in JSON, XML, CSV, and Bespoke format.
2. Create two types of user accounts which fit the use case of different users (`Penguinologist`, who want to see all the detailed information about the different species, and `Basic` users, who would appreciate a smooth user experience and mostly just want to see cute pictures of penguins rather than information.).

As a COMP2100/6442 student, you reckon, *Design Patterns* and *SOLID* are the way to go.

#### Task

**(Q3a)** Describe a good way to design the first feature. Specifically,
1. Give a general description about your ideas/design of the feature,
2. What design pattern(s) could be used
3. In what ways could this design pattern improve code quality?

**(Q3b)** Your peer have created a draft UML and some classes. Leaving in a hurry, he left a note,

> "Oops... Realized that my design violated a SOLID principle so seriously. Need your help."

Judging from his UML (and an excerpt of one of the classes)
1. Which SOLID principle has been violated?
2. Why and how it was violated (and explain why is this problematic)?
3. Explain how you could rectify this problem.

---

### 题目翻译（中文）

你正在计划开发一个关于企鹅的应用程序作为业余项目。为了构建原型，你从 Kaggle、DBpedia 收集数据，并从 Instagram 抓取帖子和媒体。

为了开始，你计划构建应用程序的框架和基本部分。具体来说，你想要：

1. 从本地文件读取应用程序的数据。数据包括各种类型的信息/内容，并且采用不同的格式。这包括 JSON、XML、CSV 和自定义格式的文件。
2. 创建两种类型的用户账户，以适应不同用户的使用场景（`企鹅学家(Penguinologist)`，想要查看关于不同物种的所有详细信息；`普通用户(Basic)`，更希望获得流畅的用户体验，主要只想看企鹅的可爱图片而不是信息）。

作为 COMP2100/6442 的学生，你认为**设计模式**和 **SOLID 原则**是正确的方向。

#### 任务

**(Q3a)** 描述设计第一个功能的良好方法。具体来说，
1. 对功能的想法/设计给出总体描述，
2. 可以使用什么设计模式，
3. 该设计模式如何提高代码质量？

**(Q3b)** 你的同伴创建了一个 UML 草图和一些类。他匆忙离开时留下了一张便条：

> "哎呀...意识到我的设计严重违反了 SOLID 原则。需要你的帮助。"

根据他的 UML（以及其中一个类的摘录）
1. 违反了哪个 SOLID 原则？
2. 为什么以及如何违反（并解释为什么这是有问题的）？
3. 解释你如何纠正这个问题。

---

## Q3 参考答案 | Reference Answer

### Q3a: Reading Data from Multiple File Formats

#### 1. General Design Description | 总体设计描述

**English:**
The feature needs to handle multiple file formats (JSON, XML, CSV, Bespoke) flexibly. The core idea is to create a unified interface for file reading while delegating format-specific parsing logic to dedicated classes. This allows the main application to work with any file type without knowing implementation details.

**中文:**
该功能需要灵活处理多种文件格式（JSON、XML、CSV、自定义格式）。核心思想是创建一个统一的文件读取接口，同时将特定格式的解析逻辑委托给专用类。这使得主应用程序可以处理任何文件类型，而无需了解实现细节。

---

#### 2. Design Pattern(s) to Use | 可使用的设计模式

**English:**
**Factory Pattern (specifically Factory Method or Abstract Factory)** would be ideal for this scenario. We can create a `FileReaderFactory` that produces appropriate file reader objects based on file type. Each reader (JSONReader, XMLReader, CSVReader, BespokeReader) implements a common `FileReader` interface.

**Structure:**
```
FileReader (interface)
├── read(): Data
│
FileReaderFactory
├── createReader(fileType): FileReader
│
Concrete Implementations:
├── JSONReader implements FileReader
├── XMLReader implements FileReader
├── CSVReader implements FileReader
└── BespokeReader implements FileReader
```

**中文:**
**工厂模式（具体来说是工厂方法或抽象工厂）** 最适合这种场景。我们可以创建一个 `FileReaderFactory`，根据文件类型生成适当的文件读取器对象。每个读取器（JSONReader、XMLReader、CSVReader、BespokeReader）实现一个共同的 `FileReader` 接口。

**结构：**
```
FileReader（接口）
├── read(): Data
│
FileReaderFactory（工厂）
├── createReader(fileType): FileReader
│
具体实现：
├── JSONReader 实现 FileReader
├── XMLReader 实现 FileReader
├── CSVReader 实现 FileReader
└── BespokeReader 实现 FileReader
```

---

#### 3. Code Quality Improvements | 代码质量提升

**English:**

**a) Extensibility:**
Adding new file formats only requires creating a new reader class and updating the factory. The existing code remains untouched, following the Open/Closed Principle.

**b) Maintainability:**
Format-specific logic is isolated in dedicated classes. If JSON parsing needs changes, only JSONReader is modified, reducing risk of breaking other formats.

**c) Testability:**
Each reader can be tested independently. Mock readers can be injected for testing higher-level components without requiring actual files.

**d) Reduced Coupling:**
Client code depends on the FileReader interface, not concrete implementations. This loose coupling makes the system more flexible and easier to refactor.

**e) Code Reusability:**
The factory and interface can be reused across different parts of the application or even in other projects with similar file-reading requirements.

**中文:**

**a) 可扩展性：**
添加新文件格式只需创建新的读取器类并更新工厂。现有代码保持不变，遵循开闭原则。

**b) 可维护性：**
格式特定的逻辑隔离在专用类中。如果 JSON 解析需要更改，只需修改 JSONReader，降低破坏其他格式的风险。

**c) 可测试性：**
每个读取器可以独立测试。可以注入模拟读取器来测试更高级别的组件，而无需实际文件。

**d) 降低耦合：**
客户端代码依赖于 FileReader 接口，而不是具体实现。这种松耦合使系统更加灵活，更易于重构。

**e) 代码复用性：**
工厂和接口可以在应用程序的不同部分甚至具有类似文件读取需求的其他项目中重用。

---

### Q3b: SOLID Principle Violation

#### 1. Which SOLID Principle is Violated? | 违反了哪个 SOLID 原则？

**English:**
**Interface Segregation Principle (ISP)** - "No client should be forced to depend on methods it does not use."

Based on the UML showing a `Penguinologist` class (and likely similar issues with `BasicUser`), the violation suggests that different user types are forced to implement or depend on interfaces with methods irrelevant to their needs.

**中文:**
**接口隔离原则（ISP）** - "不应强迫客户端依赖它不使用的方法。"

根据显示 `Penguinologist` 类的 UML（以及 `BasicUser` 可能存在的类似问题），该违规表明不同的用户类型被迫实现或依赖具有与其需求无关方法的接口。

---

#### 2. Why and How It Was Violated (and Why Problematic) | 为什么以及如何违反（以及为什么有问题）

**English:**

**How it was violated:**
The design likely uses a single `User` interface or base class with all possible user methods (e.g., `viewDetailedSpeciesInfo()`, `viewCutePictures()`, `analyzeScientificData()`, `browseGallery()`). Both `Penguinologist` and `BasicUser` must implement this "fat interface," even though:
- BasicUser doesn't need scientific analysis methods
- Penguinologist doesn't need simplified browsing methods

**Why this is problematic:**

1. **Forced Implementation:** Classes must implement methods they never use, leading to empty implementations or throwing exceptions.
2. **Maintenance Burden:** Changes to methods used by one user type force recompilation/retesting of all user types.
3. **Confusing API:** Developers using these classes see irrelevant methods, making the API harder to understand.
4. **Violation of Single Responsibility:** Classes handle responsibilities beyond their purpose.

**中文:**

**如何违反：**
该设计可能使用单一的 `User` 接口或基类，包含所有可能的用户方法（例如 `viewDetailedSpeciesInfo()`、`viewCutePictures()`、`analyzeScientificData()`、`browseGallery()`）。`Penguinologist` 和 `BasicUser` 都必须实现这个"臃肿接口"，即使：
- BasicUser 不需要科学分析方法
- Penguinologist 不需要简化的浏览方法

**为什么这有问题：**

1. **强制实现：** 类必须实现它们从未使用的方法，导致空实现或抛出异常。
2. **维护负担：** 对一种用户类型使用的方法的更改会强制重新编译/重新测试所有用户类型。
3. **令人困惑的 API：** 使用这些类的开发人员会看到不相关的方法，使 API 更难理解。
4. **违反单一职责原则：** 类处理超出其目的的职责。

---

#### 3. How to Rectify This Problem | 如何纠正此问题

**English:**

**Solution: Segregate the Interface**

Create smaller, role-specific interfaces instead of one large interface:

```java
// Core interface - shared by all users
interface User {
    String getUsername();
    void login();
    void logout();
}

// Specific interfaces for different capabilities
interface DetailedInfoViewer {
    void viewDetailedSpeciesInfo(String speciesId);
    void analyzeScientificData();
}

interface GalleryBrowser {
    void viewCutePictures();
    void browseGallery();
}

// Implementations only implement what they need
class Penguinologist implements User, DetailedInfoViewer {
    // Only implements needed methods
    @Override
    public void viewDetailedSpeciesInfo(String speciesId) { 
        // Implementation
    }
    @Override
    public void analyzeScientificData() { 
        // Implementation
    }
}

class BasicUser implements User, GalleryBrowser {
    // Only implements needed methods
    @Override
    public void viewCutePictures() { 
        // Implementation
    }
    @Override
    public void browseGallery() { 
        // Implementation
    }
}
```

**Benefits:**
- Each class only depends on methods it actually uses
- Changes to scientific features don't affect BasicUser
- Clear separation of concerns
- Easier to add new user types with specific capability combinations

**中文:**

**解决方案：隔离接口**

创建更小的、特定角色的接口，而不是一个大接口：

```java
// 核心接口 - 所有用户共享
interface User {
    String getUsername();
    void login();
    void logout();
}

// 不同功能的特定接口
interface DetailedInfoViewer {
    void viewDetailedSpeciesInfo(String speciesId);
    void analyzeScientificData();
}

interface GalleryBrowser {
    void viewCutePictures();
    void browseGallery();
}

// 实现类只实现它们需要的
class Penguinologist implements User, DetailedInfoViewer {
    // 只实现需要的方法
    @Override
    public void viewDetailedSpeciesInfo(String speciesId) { 
        // 实现
    }
    @Override
    public void analyzeScientificData() { 
        // 实现
    }
}

class BasicUser implements User, GalleryBrowser {
    // 只实现需要的方法
    @Override
    public void viewCutePictures() { 
        // 实现
    }
    @Override
    public void browseGallery() { 
        // 实现
    }
}
```

**好处：**
- 每个类只依赖它实际使用的方法
- 对科学功能的更改不会影响 BasicUser
- 清晰的关注点分离
- 更容易添加具有特定功能组合的新用户类型

---

---

## Question 4: Software Construction
## 问题4：软件构造

### 题目原文（英文）

Select two topics from the following list:
> - Design Patterns
> - Software Testing
> - Data Structures (Trees)
> - Tokenisation and Parsing
> - Persistent Data
> - Refactoring
> - Design by Contract
> - Performance Analysis
> - Intellectual Property

and answer the following questions:

A. Concisely explain both topics and how they relate to software construction, giving examples [maximum 10 sentences];

B. Examine how the two topics relate to each other [maximum 5 sentences]; and

C. Propose and explain one potential ethical issue (or negative societal/environmental impact) related to one or both topics [maximum 5 sentences].

**Note:** You must provide a justification for any claims made.

---

### 题目翻译（中文）

从以下列表中选择两个主题：
> - 设计模式
> - 软件测试
> - 数据结构（树）
> - 标记化和解析
> - 持久化数据
> - 重构
> - 契约式设计
> - 性能分析
> - 知识产权

并回答以下问题：

A. 简明扼要地解释这两个主题以及它们与软件构造的关系，并举例说明 [最多10句话]；

B. 检查这两个主题如何相互关联 [最多5句话]；以及

C. 提出并解释与一个或两个主题相关的一个潜在伦理问题（或负面社会/环境影响）[最多5句话]。

**注意：** 你必须为所做的任何声明提供理由。

---

## Q4 参考答案 | Reference Answer

### 选择的主题 | Selected Topics: 
**Design Patterns (设计模式)** and **Software Testing (软件测试)**

---

### A. Explanation of Both Topics | 对两个主题的解释

#### Design Patterns | 设计模式

**English:**
Design patterns are reusable solutions to commonly occurring problems in software design. They provide templates for writing code that is maintainable, flexible, and follows best practices. In software construction, design patterns improve code organization and communication among developers. For example, the **Singleton pattern** ensures only one instance of a class exists (useful for database connections), while the **Observer pattern** enables event-driven architectures where objects react to state changes (common in GUI applications). The **Factory pattern** abstracts object creation, making code more flexible when adding new types. These patterns reduce coupling, increase cohesion, and make code easier to understand and modify.

**中文:**
设计模式是软件设计中常见问题的可重用解决方案。它们提供了编写可维护、灵活且遵循最佳实践代码的模板。在软件构造中，设计模式改善了代码组织和开发人员之间的沟通。例如，**单例模式**确保类只有一个实例（对数据库连接很有用），而**观察者模式**支持事件驱动架构，其中对象对状态变化做出反应（在 GUI 应用程序中很常见）。**工厂模式**抽象了对象创建，使代码在添加新类型时更加灵活。这些模式降低耦合，增加内聚，使代码更易于理解和修改。

---

#### Software Testing | 软件测试

**English:**
Software testing is the systematic process of evaluating software to ensure it meets requirements and functions correctly. It identifies bugs, verifies behavior, and validates that the system works as intended. In software construction, testing is integrated throughout development to catch errors early. **Unit testing** verifies individual components (e.g., testing a sorting function), **integration testing** checks how modules work together (e.g., testing database and API interaction), and **system testing** validates the entire application. Modern practices like Test-Driven Development (TDD) write tests before code, ensuring testability is built into the design. Testing frameworks like JUnit automate this process, providing confidence in code correctness.

**中文:**
软件测试是评估软件以确保其满足要求并正确运行的系统过程。它识别错误，验证行为，并确认系统按预期工作。在软件构造中，测试在整个开发过程中集成，以尽早发现错误。**单元测试**验证单个组件（例如，测试排序函数），**集成测试**检查模块如何协同工作（例如，测试数据库和 API 交互），**系统测试**验证整个应用程序。像测试驱动开发（TDD）这样的现代实践在编写代码之前先编写测试，确保可测试性内置于设计中。像 JUnit 这样的测试框架自动化此过程，提供对代码正确性的信心。

---

### B. How the Two Topics Relate to Each Other | 两个主题如何相互关联

**English:**
Design patterns and software testing are deeply interconnected in building quality software. Well-applied design patterns significantly improve testability—for instance, the **Dependency Injection pattern** allows mock objects to be injected during testing, isolating components for unit tests. The **Strategy pattern** enables testing different algorithms independently by swapping implementations. Conversely, adopting TDD influences design decisions, often leading developers to naturally use patterns that promote loose coupling and high cohesion. Poorly chosen patterns can make testing difficult (e.g., excessive use of Singleton creates hidden dependencies), while good testing practices expose design flaws and encourage better pattern usage.

**中文:**
设计模式和软件测试在构建高质量软件方面深度关联。应用良好的设计模式显著提高可测试性——例如，**依赖注入模式**允许在测试期间注入模拟对象，隔离组件进行单元测试。**策略模式**通过交换实现使不同算法独立测试成为可能。相反，采用 TDD 影响设计决策，通常会引导开发人员自然使用促进松耦合和高内聚的模式。选择不当的模式会使测试变得困难（例如，过度使用单例会创建隐藏依赖），而良好的测试实践会暴露设计缺陷并鼓励更好地使用模式。

---

### C. Ethical Issue | 伦理问题

**English:**
One significant ethical issue is **inadequate testing leading to software failures with severe societal consequences**. When companies prioritize speed over thorough testing, especially in safety-critical systems (medical devices, autonomous vehicles, financial systems), design patterns may be misapplied or testing may be insufficient, resulting in bugs that cause harm or death. For example, the Boeing 737 MAX crashes were partly attributed to software flaws that inadequate testing failed to catch. This reflects an ethical failure where profit motives override the responsibility to ensure software safety through comprehensive testing and sound architectural design. Companies must balance market pressure with the moral obligation to rigorously test software, particularly when human lives depend on it.

**中文:**
一个重要的伦理问题是**测试不足导致的软件故障带来严重社会后果**。当公司优先考虑速度而非彻底测试时，特别是在安全关键系统（医疗设备、自动驾驶汽车、金融系统）中，设计模式可能被误用或测试可能不足，导致造成伤害或死亡的错误。例如，波音 737 MAX 坠机事故部分归因于软件缺陷，而不充分的测试未能发现这些缺陷。这反映了一种伦理失败，即利润动机凌驾于通过全面测试和健全架构设计确保软件安全的责任之上。公司必须在市场压力与严格测试软件的道德义务之间取得平衡，特别是当人类生命依赖于此时。

---

---

## 格式说明 | Format Notes

- 本文档使用 Markdown 格式
- 中英文内容对照排列
- 代码示例使用代码块格式
- 每个答案都提供了详细的理由和例子
- 符合题目要求的字数限制

---

**文档生成时间:** 2025年11月9日  
**适用课程:** COMP2100/6442 Software Design & Implementation
